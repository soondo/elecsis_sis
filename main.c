/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.0.1   2018-10-14

The MIT License (MIT)
Copyright (c) 2018 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/

/* Includes */
#include <stddef.h>
#include "stm32l0xx.h"
#include <stdbool.h>
#include "l0xx_ctrl_redef.h"


#define		_GRN_LED_ON						GPIOA->BSRR |= GPIO_BSRR_BS_5		// Nucleo-64/STM32L073RZTx보드에서 녹색LED는 PA5에 연결되어 있다.
#define		_GRN_LED_OFF					GPIOA->BSRR |= GPIO_BSRR_BR_5



// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     초기화용 Procedure들     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// ==================================     HSE 선택과 확인처리 Procedure들      ==================================
void	set_hse_osc_equip_on()
{
	_HSE_OSC_ON;																				// 만일 사용할 Clock source를 외부X-tal osc로 하겠다면 osc장치를 가동하고...
	while((RCC->CR & RCC_CR_HSERDY) == 0)										//   ...osc장치가 가동된 것이 확실할 때 Clock의 출력이 안정적으로 확립되었는지의 Flag 확인을 한 후...
		;
}
void	set_hse_clk_to_sysclk()
{
	_HSE_CLK_TO_SYSCLK;																	//           ...HSE Clock이 생성되어 있고 이를 System clock으로 사용하겠다면 시스템Clock으로 연결하는 선택bit들을 set하고...
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSE)	//             ...이 선택의 결과Flag이 올 때까지 기다린다.
		;
}


// ===============================    HSE bypass 선택과 확인처리 Procedure들    ===============================
void	set_hse_bypas_on()
{
	_HSE_BYP_ON;																				// HSE X_tal을 생략하고 OSC_IN으로 외부Clock을 받아서 사용할 때는 HSEON과 HSEBYP의 2개 bit를 모두 set한 후...
	while((RCC->CR & RCC_CR_HSEBYP) == 0)										//   ...HSE Bypass 선택bit가 확실히 set된 것이 확실하고...
		;

	while((RCC->CR & RCC_CR_HSERDY) == 0)										//        ...외부Clock이 HSE장치에서 확실히 출력되었는지의 확인도 되었다면 다음으로.
		;
}
void	set_hsebyp_clk_to_sysclk()
{
	_HSE_CLK_TO_SYSCLK;																	// HSE Clock이 생성되어 있고 이를 System clock으로 사용하겠다면 시스템Clock으로 연결하는 선택bit들을 set하고...
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSE)	//   ...이 선택의 결과Flag이 올 때까지 기다린다.
		;
}

// =================================     HSI16 선택과 확인처리 Procedure들     =================================

		// *** HSI16을 분주없이 사용하겠다면
void	set_hsi16_on()
{
	_HSI16_OSC_ON;																				// 만일 사용할 Clock source를 내부 RCosc로 하겠다면 osc장치를 가동하고...
	while((RCC->CR & RCC_CR_HSIRDY) == 0);										//   ...osc장치가 가동된 것이 확실할 때 Clock의 출력이 안정적으로 확립되었는지의 Flag 확인을 한 후...
		;
}

		// *** HSI16을 4분주로 사용하겠다면('0', '4'분주 2종류 있음)
void	set_hsi16_on_divide()
{
	_HSI16_ON_AND_DIVIDE;																															// 만일 HSI16을 ON하고 4분주를 허용하였다면... ---> 기본은 '0' : '분주없음
	while((RCC->CR & (RCC_CR_HSIRDY | RCC_CR_HSIDIVF)) != (RCC_CR_HSIRDY | RCC_CR_HSIDIVF))		//  ...이 장치가 활성되어 Clock이 안정적으로 발생하였는지와...
		;																																							//    ...분주가 허용되었는지의 결과Flag이 확인될 때까지 대기한다.
}
void	set_hsi16_clk_to_sysclk()
{
	_HSI16_CLK_TO_SYSCLK;																//  HSI16 Clock이 생성되어 있고 이를  System Clock으로 사용하기 위하여 HSI16을 시스템Clock으로 연결하는 선택bit들의 set하고...
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)		//	    ...이 선택의 결과Flag이 올 때까지 대기한다.
		;
}


// =================================      PLL 선택과 확인처리 Procedure들      =================================
void	set_pll_config_and_equip_on()
{
// PLL Multipl- 의 초기값은 4개 bit 모두 '1'의 값이고 이 값은 해당사항이 없는 값이다.
	_PLL_EQUIP_OFF;																			// 먼저 장치를 끄고...
	_PLL_HSE_CLK_SETTING;																//    ...Clock source, 체배값 및 분주값을 설정(현재는 HSE, 8체배 그리고 2분주로 설정되어 32MHz로 설정되어 있음)한 후...
	_PLL_EQUIP_ON;																				//      ...PLL장치를 가동하고...
	while((RCC->CR & RCC_CR_PLLRDY) == 0)										//        ...이제 PLL clock이 안정되게 확립되었는지의 Flag을 확인하면서 확정될 때까지 대기한다.
		;
}
void	set_pll_clk_to_sysclk()
{
	_PLL_TO_SYSCLK;																			// 시스템클록으로의 선택에서도 먼저 연결bit를 한 번 지우고 다시 시스템클록으로 선택한 후......														//   ...
	while((RCC->CFGR & RCC_CFGR_SWS) !=RCC_CFGR_SWS_PLL)		//   ...PLL클록이 시스템클록으로 확실히 출력되었는지의 Flag을 확인한다.
		;
}
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     END '초기화용 Procedure들'    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@




// ########################################################     초기화 처리함수들     ########################################################

// *****     System clock으로 사용할 Source클록의 선택과 HCLK의 생성 및 APB1, APB2의 PCLK 생성과 PLL연결등의 처리
void sysclk_src_and_equip_initialize()
{
	_EQUIP_PWR_RESET;																// 먼저, APB1의 Clock interface 전원을 차단하여 장치의 Clock을 차단한  후...
	_SET_PWR_LEVEL18;																//   ... 공급전압을 1.8V로 바꾸겠다면 설정한 다음...  ---> 시스템Clock이 16MHz~ 이면 1.8v의 대응값으로 되어 있다.
	_EQUIP_PWR_ON;																	//     ...장치의 Clock을 허용하고...


//	while((PWR->CSR & PWR_CSR_VOSF) == 0)								//          ...내부 Regulator가 선택한 설정전압 1.8V('1'이면 선택한 전압)으로 교체하여 이 전압이 안정되었는지를 확인한다.
//		;																							//             (어쨋거나 이 대기문은 빠져나오지 못한다. 원인규명은 실패)


/*
  set_hse_osc_equip_on();																// HSE의 외부X-tal osc의 사용을 원하면 OSC의 장치를 활성한 후 Clock이 안정되게 출력하고 있는지를 보고 확실할 때...
  set_hse_clk_to_sysclk();																//   ...이를 시스템Clock으로 HSE를 선택하고자 할 때 선택하고 이 선택의 결과Flag을 확인하여 확실하다면.
*/

	set_hse_bypas_on();																	// HSE의 외부Clock을 사용하기 위하여 OSC의 장치를 활성하고 Clock이 안정되게 출력하고 있는지도 확인되었고...
//	set_hse_clk_to_sysclk();															//   ...시스템Clock으로 HSEBYP를 선택한 후 이 선택의 결과Flag을 확인하여 확실하다면.
																									//         *** 이 사용은 mbed보드 'stm32l073rz'에 맞춘 것이다. 이 보드는 Built-in의 'ST-LINK/V2-1'로 부터 8MHz의
																									//                MCO Clock을 HSE의 'OSC_IN'으로 받는다. 8MHz를 그냥 시스템Clock으로 사용하겠다면 이 선택을 하면 된다. ***

/*
 	set_hsi16_on_divide();																//	HSI16을 ON하고 분주도 허용하여 이들 두 설정들이 활성되었는지도 본 후 확실할 때...
  	set_hsi16_clk_to_sysclk();														//   ...시스템Clock을 HSI16으로 하고자 하면 선택하고  이의 결과Flag을 확인하여 시스템Clock으로 선택된 것이 확실하다면.
 */


	FLASH->ACR |=FLASH_ACR_LATENCY;									//	 가장 먼저 읽기 대기상태('1')를 가지게 한 후...     ---> 대기시간을 가지면 '0'(없을 때)일 때보다 처리시간이 증가된다.
	while ((FLASH->ACR & FLASH_ACR_LATENCY) == 0)
		;

	FLASH->ACR |= FLASH_ACR_PRFTEN;									//       ...Flash 읽기에서 선행읽기(Bufferring)을 사용하겠다면 허용한다.

 	set_pll_config_and_equip_on();												// 'stm32l073rz'보드의 HSEBYPASS는 앞 단 MCO의 8MHz가 입력된다. 그러므로 시스템Clock을 32MHz로 사용하겠다면...
 	set_pll_clk_to_sysclk();															//    ...설정한 PLL clock을  선택한다.

   _AHB_CLK_DIV;																		//  이제 최종적으로 SYSCLK을 '1'분주(다른 분주값은 이 매크로에서 처리)하여 AHB장치(Bridge)에서 출력하고... ---> AHB Bus에 HCLK 생성.
   _APB1_CLK_DIV;																		//    ...APB1을 '1'분주(다른 분주값은 이 매크로에서 처리)하여 HCLK을 그대로 APB1 장치에서 출력한다 ---> APB1 Bus에 PCLK이 생성.
   _APB2_CLK_DIV;																		// 	  ...APB2를 '1'분주(다른 분주값은 이 매크로에서 처리)하여 HCLK을 그대로 APB2 장치에서 출력한다 ---> APB2 Bus에 PCLK이 생성.
}



/* ===================================   포트 핀의 Mode와 입.출력 설정에 따른 Pull-up/down 설정의 임의결정   ===================================

  - GPIO들의 설정처리 (GPIO의 Pin들 각각은 4개 Mode로 설정가능하고 Mode는 전원Reset시 Analog mode로 초기화된다) ...... 입.출력Mode만 'l0xx_ctrl_redef.h'
     에서 재 정의 하였다.
  - GPIO핀들의 Alternate function과 Analog mode에서의 처리는 시스템정의대로 처리한다.

  ** 포트 핀이 입력으로 설정되었을 때 만일 외부(장치)의 입력상태가 Pull-up으로 되어 있다고 가정하면, 이 경우 포트 핀에서는 Pull-down으로 설정하는 것이
      전력소모가 더 적어진다. 이는 포트 핀의 Pull-up/down저항이 약한 상태의 Pull-up/down이므로 연결상태의 저항이 아주 크기 때문이다. 만일 외부 Pull-
      up저항과 포트 Pull-up저항의 병렬상태라면 전체의 저항값이 작아져서 외부(장치)의 Lo-active 초기싯점에서 큰 잡음이 발생할 것으로 본다. 물론 시스템이
      Pull-up/down저항값을 조정하기에 이러한 유추가 틀렸을 수도 있다.

      포트 핀을 입력으로 설정하였을 때의 포트 핀의 Pull-up/down의 선택은 설계시 결정한 외부(장치)의 Pull-up/down의 상태와 반대로 설정하는 것을 임의 결정한다.

  ** 포트 핀이 출력으로 설정되어 있을 때 전기적 저항이 거의 없는 출력SW가, 연결되어 있는 외부(장치)에게 전력을 공급하거나(Source) 또는 외부의 연결(장치)로
      부터 전류가 흘러 들어오거나(Sunk)의 작동을 한다. 이 경우 외부(장치)의 작업이 중단되어서 포트가 Tri-state가 된 상태를 맞았다면 이 때는 잡음 등의 여러가지
      를 참조하였을 때 포트를 Pull-down상태로 유지하는 것이 유리하다고 본다.

      포트 핀을 출력으로 설정하였을 때는 포트 핀을 Pull-down으로 설정하는 것으로 임의 결정한다.
   ======================================================================================================================================= */

// GPIOA의 Mode 처리
void	gpioa_init()
{
	_GPIOA_CLK_ENABLE;																													// 먼저 GPIOA의 Clock을 허용하고...

// *** GPIO의 Pin들 각각은 4개 Mode로 설정가능하다. 전원Reset시 Mode설정 bit 모두
//     	'1:1' 로서 전체 Porter핀들 거의는 Analog mode로 초기화된다.
	GPIOA->MODER &= ~(i_PA11 |  o_PA5 | o_PA8 | o_PA15);																//     ...PortA의 11번 Pin은 입력으로, 5번, 8, 15번 Pin은 출력으로 설정한 후...
																																						//                                                    ---> PA.5는 mbed에서 녹색LED이고 '1' 출력에서 점등
	GPIOA->MODER = (GPIOA->MODER & (~GPIO_MODER_MODE8)) | GPIO_MODER_MODE8_1;		//        ...MCO로 출력할 8번 핀은 Alternate function으로 설정하고...
																																						// 		     (stm32l073보드의 MCO출력을 PA8로(Alternate/1:0로 설정하여야 한다) 선택한다)
//	GPIOA->OTYPER |= GPIO_OTYPER_OT_8; --> 'Open-drain' ;  *** PA8을 'Open-drain'으로 설정하면 MCO는 출력 안 됨.
// *** GPIO의 모든 핀은 전원Reset 시 Pin 출력에서의 상태를 결정하는 bit인 'OTYPER' 레지스터의 bit가 '0'이
//       되므로서 Push-pull 상태로 초기화된다. 설정bit가 '1'이면 출력Pin은 'open-drain'이 된다.

	GPIOA->OSPEEDR = (GPIOA->OSPEEDR & (~GPIO_OSPEEDER_OSPEED8)) | GPIO_OSPEEDER_OSPEED8_1;  // ...MCO출력인 PA.8만 'Hight speed', 나머지 출력들은 초기값인 'Low-speed'로 사용하며...
// *** GPIO Pin들이 출력으로 설정될 때 Pin 출력Speed를 결정하는 'OSPEEDER'레지스터의 설정bit 'b1:b0' 은
//       전원Reset 시 PA13만 'Very high speed'이고 나머지 핀과 다른 포트 모두는 '0:0'으로서 이는 'Low-speed'이다.
	//	 GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEEDx_0;//실행하면 'Medium-speed'.
	// GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEEDx_1;// 실행하면 'High-speed'

	GPIOA->PUPDR = (GPIOA->PUPDR & (~(GPIO_PUPDR_PUPD5 | GPIO_PUPDR_PUPD8 | GPIO_PUPDR_PUPD11 | GPIO_PUPDR_PUPD15)))\
							  | GPIO_PUPDR_PUPD5_1 | GPIO_PUPDR_PUPD8_1 | GPIO_PUPDR_PUPD11_1 | GPIO_PUPDR_PUPD15_1;
																																						//	                              ...입.출력 4개 핀 모두의 상태를 Floating(0:0)으로 처리한 후...
																																						//					                ...Pull-down(Alternate인 PA.8은 Pull-up, -down 관계없음)으로 하고...
																																						//                                  ...입력핀은 Pull-down으로 설정한다.
}

/*
// GPIOB의 Mode 처리
void	gpiob_init()
{
	_GPIOB_CLK_ENABLE;																													// GPIOB의 Clock허용.
	GPIOB->MODER &= ~o_PB8;
	GPIOB->PUPDR |= ~GPIO_PUPDR_PUPD8_1;
}
*/

// GPIOC의 Mode 처리
void	gpioc_init()
{
	_GPIOC_CLK_ENABLE;																													// GPIOC의 Clock허용.
	GPIOC->MODER &= ~(i_PC10 | i_PC12 | i_PC13 | o_PC5 | o_PC6 | o_PC8);										// PC.10, 12, 13(청색PB : 'USER'/Lo- Active))을 입력으로, PC.5, 6, 8은 출력으로 설정.
	//																																					// 출력핀들은 모두 Push-pull로 설정.
	//																																					// 출력핀들의 Speed는 모두 Low-speed로 설정.
	GPIOC->PUPDR = (GPIOC->PUPDR & (~(GPIO_PUPDR_PUPD5 | GPIO_PUPDR_PUPD6 | GPIO_PUPDR_PUPD8 | GPIO_PUPDR_PUPD10 | GPIO_PUPDR_PUPD12 | GPIO_PUPDR_PUPD13)))\
								| GPIO_PUPDR_PUPD5_1 | GPIO_PUPDR_PUPD6_1 | GPIO_PUPDR_PUPD8_1 | GPIO_PUPDR_PUPD10_1 | GPIO_PUPDR_PUPD12_1 | GPIO_PUPDR_PUPD13_1;
																																						// 출력핀들은 모두 PP+Pull-down으로,  입력핀들은 Pull-down으로 설정.
}

// GPIOD의 Mode 처리
void	gpiod_init()
{
	_GPIOD_CLK_ENABLE;																													// GPIOD의 Clock허용.
	GPIOD->MODER &= ~(i_PD2 | o_PD8 | o_PD13);																			// PD.2는 입력, PD.8, 13은 출력으로 설정.
	//																																					// 출력핀들은 모두 Push-pull로 설정.
	//																																					// 출력핀들의 Speed는 모두 Low-speed로 설정.
	GPIOD->PUPDR = (GPIOD->PUPDR &= ~(GPIO_PUPDR_PUPD2 | GPIO_PUPDR_PUPD8 | GPIO_PUPDR_PUPD13))\
															   | GPIO_PUPDR_PUPD2_1 | GPIO_PUPDR_PUPD8_1 | GPIO_PUPDR_PUPD13_1;  //PD2 입력핀은 Pulldown으로, PD8, 13 출력핀은 PP + Pulldown으로 설정.
}
// ######################################################    END '초기화 처리함수들'    ######################################################







// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     SysTick 사용시의 전역변수들     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// ***********        SysTick의 timer 이용을 위한 변수들과 설정       ***********
	// system clock이 32MHz일 때 정해진 24bit의 최대값으로 분주하면 524.287ms이고 이용할 수 있는 가장 긴 지연시간이다.
	// 만일 더 긴 지연시간을 SysTick으로 부터 얻고자 한다면 여러 정의하는 단위시간을 여러 번 계수하여야 할 것이다.

volatile		bool		b_delay_ms_time_out = false;
uint32_t	delay_unit_val;
uint32_t	set_tick_val;
uint32_t 	delay_time_val;
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     SysTick 사용시의 사용함수     !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// ***********    SysTick의 한계계수값 확인, 설정과 Clock공급 처리     ***********
		// 500ms가 넘는 시간의 지연값을 원할 때는  100ms의 단위로 SysTick을 부르면서 갯수를 계수하여 달성한다.

void		systick_delay_ms(uint16_t	 Desired_value)
{
		delay_time_val = Desired_value;

		if(delay_time_val <=	500)																				// SysTick 사용의 희망 지연시간이 1~500ms 이면...
			delay_unit_val = 500;																				//   ...SysTick으로의 전달값을 '500'(ms)으로 설정하고...

		else
			delay_unit_val = 100;																				//      ...희망하는 지연시간이 500ms를 넘길 때는 전달값을 '100'(ms)로 설정하여...

		set_tick_val = delay_unit_val * 32000;															//          ...32MHz라면 1ms/clk 출력인 32000clk 마다의 값에 지연을 희망하는 시간값을 적산한 후...

		if ((set_tick_val-1) > SysTick_LOAD_RELOAD_Msk){									// 			 ...지연해야 할 시간이 설정의 최대값인 24bit 보다 더 큰지를 확인하는데 ...
			_GRN_LED_ON;																						//                ...크다면 이는 Error이다.
			while(1)
				;
		}

	// *** SysTick은 24bit이고 가동되면 'SysTick->LOAD'로 설정된 값으로 부터 Down count 되는데 '1'->'0'에서 'COUNTFLAG'이 set되며 설정값은 다시
	//        Reload되어서 재 실행되면서 'COUNTFLAG'은 지워지며, 물론 Interrupt가 허용되어 있다면 실행한다.
		NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);					// 지연을 원하는 시간의 설정값이 최대값 이 내라면 먼저 SysTick의 인터럽트 우선순위를 처리하고...
		SysTick->LOAD  = set_tick_val-1;																//     ...Reload값으로 설정하고...
		SysTick->VAL = 0;																						//       ...현재값을 '0'으로 설정한 후...
		SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk;									//		    ...SysTick장치에 Clock을 공급한다.
}
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



// 시스템에 전원이 공급되어 PWR ON Reset이 되면 이 싯점까지에서 'SystemInit()'을 불러 MSI Clock중 2.1MHz의 Clock이 시스템클록(SYSCLK)이 되어 시스템이 시작된다.

int main(void)
{
	sysclk_src_and_equip_initialize();

	gpioa_init();
//	gpiob_init();
	gpioc_init();
	gpiod_init();

	RCC->CFGR = (RCC->CFGR & ~(RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE)) | RCC_CFGR_MCOPRE_DIV1 | RCC_CFGR_MCO_SYSCLK; // MCO출력을 할 경우.
																												 // MCO Clock출력을 '분주없음'으로 설정하고 Clock source는 System clock으로 결정하여 출력한다 --> 확인완료.

	static	uint32_t	delay_time_100ms_num = 0;

	while(1)
	{
			if(!_CHK_SYSTICK_START){																// SysTick이 정지되어 있는지 보고 정지일 때...
				systick_delay_ms(500);																	//   ...원하는 지연시간을 넘긴 후...        ---> 500ms 까지는 한 번에 처리하고 넘는 시간은 100ms 단위를 계수처리.
				_SYSTICK_INT_ENABLE;																//     ...SysTick 인터럽트를 허용하고...
				_SYSTICK_START;																		//       ...SysTick을 가동한다.
				_GRN_LED_ON;
			}

			while(b_delay_ms_time_out){
					if(delay_unit_val == 100){															// 만일 지연을 원하는값이 500ms를 넘는 값이면 100ms 단위로 계수하기 위한 처리를 한다.
						delay_time_100ms_num++;

						if((delay_time_val/delay_unit_val) == delay_time_100ms_num)
							delay_time_100ms_num = 0;
						else{
							b_delay_ms_time_out = false;
							break;
						}
					}

					if((GPIOA->IDR & GPIO_IDR_ID5))
						_GRN_LED_OFF;
					else
						_GRN_LED_ON;

					b_delay_ms_time_out = false;
			}
	}

  return 0;
}



void	SysTick_Handler()
{
	b_delay_ms_time_out = true;
}

